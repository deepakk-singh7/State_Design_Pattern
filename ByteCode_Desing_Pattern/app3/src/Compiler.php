<?php 
/**
 * The Compiler for the Wizard Duel Game.
 *
 * This class is responsible for taking a high-level, human-readable spell
 * definition (from a JSON file) and compiling it into a low-level array
 * of integer-based instructions (bytecode) that the VM can execute.
 */
require_once 'Instruction.php';

class Compiler {

    /**
     * A static map of instruction names to their integer codes.
     *
     * This is populated once using reflection on the Instruction class constants.
     * Caching it statically prevents re-calculating it for every compilation.
     * e.g., ['LITERAL' => 1, 'ADD' => 20, ...]
     *
     * @var array<string, int>|null
     */
    private static ?array $instructionMap = null; 

    /**
     * Compiler constructor.
     *
     * Populates the instruction map if it hasn't been initialized yet.
     * It uses reflection to dynamically read the constants from the `Instruction`
     */
    public function __construct(){
        if (self::$instructionMap === null) {
            $refl = new \ReflectionClass('Instruction');
            self::$instructionMap = $refl->getConstants();
        }
    }

    /**
     * Compiles a spell from a JSON file into bytecode.
     *
     * This method reads a JSON file, validates its structure and content, and translates the list of instructions into a linear array of integers.
     * @param string $fileName The absolute path to the spell's JSON file.
     * @return int[] The generated bytecode array.
     * @throws \Exception If the file doesn't exist, is unreadable, contains invalid JSON, or has an invalid instruction format.
     */
    public function compile(string $fileName): array {
        // echo $fileName . PHP_EOL;
        // 1. Check for the file's existence.
        if (!file_exists($fileName)) {
            throw new \Exception("Spell file not found: {$fileName}\n");
        }

        // 2. Read the entire file content.
        $jsonContent = file_get_contents($fileName);
        if ($jsonContent === false) {
            throw new \Exception("Could not read spell file: {$fileName}\n");
        }

        // 3. Decode the JSON string into a PHP associative array.
        $spellData = json_decode($jsonContent, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \Exception("Invalid JSON in spell file: {$fileName} - " . json_last_error_msg());
        }

        // 4. Validate the structure of the decoded spell data.
        if (!isset($spellData['instructions']) || !is_array($spellData['instructions'])) {
            throw new \Exception("No instructions found in spell file: {$fileName}");
        }

        if (empty($spellData['instructions'])) {
            throw new \Exception("Empty instructions in spell file: {$fileName}");
        }

        // 4a. Validate each individual instruction before processing.
        foreach ($spellData['instructions'] as $index => $instruction) {
            if (!isset($instruction['code']) || !is_string($instruction['code'])) {
                throw new \Exception("Invalid instruction at index {$index} in {$fileName}: missing or invalid 'code'");
            }
            
            $instructionName = strtoupper($instruction['code']);
            if ($instructionName === 'LITERAL' && !isset($instruction['value'])) {
                throw new \Exception("LITERAL instruction at index {$index} missing 'value' in {$fileName}");
            }
        }

        // 5. Begin the compilation process.
        $bytecode = [];
        foreach ($spellData['instructions'] as $instruction) {
            $instructionName = strtoupper($instruction['code']);
            // Look up the instruction's numeric code in our map.
            if (isset(self::$instructionMap[$instructionName])) {
                // Add the instruction's numeric code to the bytecode.
                $bytecode[] = self::$instructionMap[$instructionName];

                // If it's a LITERAL, add its value as the next item in the bytecode.
                if ($instructionName === 'LITERAL' && isset($instruction['value'])) {
                    $bytecode[] = (int)$instruction['value'];
                }
            }
        }

        return $bytecode;
    }
}